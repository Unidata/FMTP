#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""@package recvLogParser
 Copyright (C) 2015 University of Virginia. All rights reserved.

 file      recvLogParser.py
 author    Shawn Chen <sc7cq@virginia.edu>
 version   1.0
 date      June 27, 2015

 LICENSE

 This program is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the Free
 Software Foundation; either version 2 of the License, or（at your option）
 any later version.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 more details at http://www.gnu.org/copyleft/gpl.html

 brief     parses log files generated by VCMTPv3 receivers
 usage     python recvLogParser.py <logfile-to-read> <newfile-to-write>
"""


import re
import sys
import datetime


def checkTimeElapse(start, end):
    """Checks if the elapsed time is longer than 1 minute.

    Takes the start time and end time, checks if the elapsed time is longer
    than one minute. If so, returns True. Otherwise, returns False.

    Args:
        start: Start of the time, should be a datetime struct
        end  : End of the time, should be a datetime struct

    Returns:
        True : Elapsed time is longer than 1 minute.
        False: Elapsed time is shorter than 1 minute.
    """
    if end > start:
        over_one_min = (end - start) > datetime.timedelta(minutes = 1)
    else:
        over_one_min = (start - end) > datetime.timedelta(minutes = 1)
    return over_one_min


def parseSizeTime(line):
    """Parses the product size and receiving time in a line.

    Parses the product size and receiving time consumed for the product in
    the given line of log file.

    Args:
        line: A line of the raw log file.

    Returns:
        (-1, -1, -1): If no valid size or time is found.
        (prodindex, prodsize, rxtime): A tuple of product index, product size
                                       and receiving time.
    """
    success_match = re.search(r'.*\[SUCCESS\].*#(\d+)', line)
    if success_match:
        sizematch = re.search(r'.*size = (\d+) bytes', line)
        timematch = re.search(r'.*time = (\d+\.\d+) seconds', line)
    if success_match and sizematch and timematch:
        prodindex = int(success_match.group(1))
        size      = int(sizematch.group(1))
        rxtime    = float(timematch.group(1))
        return (prodindex, size, rxtime)
    else:
        return (-1, -1, -1)


def parseFailure(line):
    """Parses the log to find unsuccessfully received products.

    Parses the failure message in log to find unsuccessfully received products,
    which are caused by retransmission timeouts. Since we are not able to tell
    whether a product is failed or simply out-of-sequence, we cannot detect
    failure by looking at product indices. The only reliable way is the failure
    message in log file.

    Args:
        line: A line of the raw log file.

    Returns:
        -1: If no failure message is found.
        prodindex: Index of the product which is indicated lost.
    """
    failure_match = re.search(r'.*\[FAILURE\].*#(\d+)', line)
    if failure_match:
        return int(failure_match.group(1))
    else:
        return -1


def parseMcastData(line):
    """Parses the log to find multicast data blocks.

    Parses the log to find multicast data blocks.

    Args:
        line: A line of the raw log file.

    Returns:
        -1: If no multicast block is found.
        prodindex: Index of the product which has multicast blocks.
    """
    mcast_match = re.search(r'.*\[MCAST DATA\].*#(\d+)', line)
    if mcast_match:
        return int(mcast_match.group(1))
    else:
        return -1


def parseRetxData(line):
    """Parses the log to find retransmitted data blocks.

    Parses the log to find retransmitted data blocks.

    Args:
        line: A line of the raw log file.

    Returns:
        -1: If no retransmitted block is found.
        prodindex: Index of the product which has retransmitted blocks.
    """
    retx_match = re.search(r'.*\[RETX DATA\].*#(\d+)', line)
    if retx_match:
        return int(retx_match.group(1))
    else:
        return -1


def main(filename, newfile):
    """Reads the raw log file and parses it.

    Reads the raw VCMTPv3 log file, parses each line and computes throughput,
    block-based retransmission rate and successfully received  products on a
    basis of 1 minute.

    Args:
        filename: Filename of the log file.
        newfile : Filename of the new file to contain output results.
    """
    f = open(filename, 'r')
    w = open(newfile, 'w+')
    # unit is byte
    bytes_in_minute  = 0
    # unit is second
    rxtime_in_minute = 0
    basetime         = datetime.datetime(2000, 1, 1, 0, 0, 0)
    baseline         = 0
    prod_in_minute   = 0
    fail_in_minute   = 0
    block_in_minute  = 0
    retx_in_minute   = 0
    for i, line in enumerate(f):
        timestamp_match = re.search(r'^\d+-\d+-\d+ \d+:\d+:\d+  ', line)
        eventtime = datetime.datetime.strptime(timestamp_match.group(0),
                                               "%Y-%m-%d %H:%M:%S  ")
        if not i:
            basetime = eventtime
            baseline = i
            continue
        (prodid_success, size, rxtime) = parseSizeTime(line)
        prodid_failure = parseFailure(line)
        prodid_mcast = parseMcastData(line)
        prodid_retx = parseRetxData(line)
        if checkTimeElapse(basetime, eventtime):
            # throughput unit is bps
            minute_based_thru = float(bytes_in_minute) / 60 * 8
            if rxtime_in_minute:
                prod_based_thru = float(bytes_in_minute) / rxtime_in_minute * 8
            else:
                prod_based_thru = 0
            print 'minute_based_throughput =', minute_based_thru
            print 'product_based_throughput =', prod_based_thru
            if prod_in_minute:
                success_in_minute = prod_in_minute - fail_in_minute
                reliability = float(success_in_minute / prod_in_minute) * 100
                print 'reliability =', reliability
            if block_in_minute:
                retx_rate = float(retx_in_minute / block_in_minute) * 100
                print 'retx rate =', retx_rate
            tmp_str = str(minute_based_thru) + ',' + str(prod_based_thru) \
                    + ',' + str(reliability) + ',' + str(retx_rate) + '\n'
            w.write(tmp_str)
            # starts again for next new minute, re-initialize
            basetime = eventtime
            baseline = i
            bytes_in_minute  = 0
            rxtime_in_minute = 0
            prod_in_minute   = 0
            fail_in_minute   = 0
            block_in_minute  = 0
            retx_in_minute   = 0
            # process next new minute
            if prodid_success >= 0:
                bytes_in_minute  = size
                rxtime_in_minute = rxtime
                prod_in_minute   += 1
            if prodid_failure >= 0:
                prod_in_minute += 1
                fail_in_minute += 1
            if prodid_mcast >= 0:
                block_in_minute += 1
            if prodid_retx >= 0:
                block_in_minute += 1
                retx_in_minute  += 1
        else:
            if prodid_success >= 0:
                bytes_in_minute  += size
                rxtime_in_minute += rxtime
                prod_in_minute   += 1
            if prodid_failure >= 0:
                prod_in_minute += 1
                fail_in_minute += 1
            if prodid_mcast >= 0:
                block_in_minute += 1
            if prodid_retx >= 0:
                block_in_minute += 1
                retx_in_minute  += 1

    f.close()
    w.close()


if __name__ == "__main__":
    main(sys.argv[1], sys.argv[2])
